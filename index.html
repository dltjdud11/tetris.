<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ëª¨ë°”ì¼ í…ŒíŠ¸ë¦¬ìŠ¤ ê²Œì„ (ìµœì¢… ë²„ê·¸ ìˆ˜ì •)</title>
    
    <style>
        /* CSS ìŠ¤íƒ€ì¼ (ë³€ë™ ì—†ìŒ) */
        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding-top: 20px;
            background-color: #333;
            font-family: Arial, sans-serif;
            color: white;
            overflow: hidden; 
            user-select: none;
            box-sizing: border-box;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background-color: #222;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #game-board {
            display: grid;
            grid-template-rows: repeat(20, 1fr); 
            grid-template-columns: repeat(10, 1fr);
            width: 300px; 
            height: 600px;
            border: 3px solid #ccc;
            background-color: #111;
        }

        .cell {
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            border: 1px solid #000;
        }

        /* í…ŒíŠ¸ë¡œë¯¸ë…¸ ë¸”ë¡ ìƒ‰ìƒ */
        .T { background-color: purple; border-color: #6a0080; }
        .L { background-color: orange; border-color: #cc6600; }
        .J { background-color: blue; border-color: #000080; }
        .S { background-color: green; border-color: #004d00; }
        .Z { background-color: red; border-color: #800000; }
        .I { background-color: cyan; border-color: #008080; }
        .O { background-color: yellow; border-color: #808000; }

        .info-panel {
            width: 300px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            font-size: 1.2em;
        }
        
        #start-button {
            padding: 10px 15px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        /* ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ìŠ¤íƒ€ì¼ë§ */
        .controls {
            display: flex;
            justify-content: space-around;
            width: 100%;
            padding: 15px 0;
        }

        .controls button {
            padding: 15px 25px;
            font-size: 24px;
            background-color: #444;
            color: white;
            border: 2px solid #666;
            border-radius: 10px;
            cursor: pointer;
            touch-action: manipulation; 
            flex-grow: 1; 
            margin: 0 5px;
            min-width: 60px;
            height: 60px;
        }

        @media (max-width: 600px) {
            #game-board, .info-panel {
                width: 90vw; 
                max-width: 300px;
            }
            #game-board {
                height: calc(90vw * 2); 
                max-height: 600px;
            }
            .controls {
                width: 90vw;
                max-width: 320px;
            }
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div class="info-panel">
            <p>SCORE: <span id="score">0</span></p>
            <button id="start-button">START</button>
        </div>
        
        <div id="game-board">
            </div>
        
        <div class="controls">
            <button id="left">â¬…ï¸</button>
            <button id="rotate">ğŸ”„</button>
            <button id="right">â¡ï¸</button>
            <button id="down">â¬‡ï¸</button>
        </div>
    </div>
    
    <script>
        // --- ê²Œì„ ì„¤ì • ---
        const COLS = 10;
        const ROWS = 20;
        let score = 0;
        let gameBoard = []; 
        let gridState = Array(COLS * ROWS).fill(null); 
        
        let currentTetromino;
        let currentTetrominoName;
        let currentRotation = 0;
        let currentPosition = 4;
        let timerId = null;

        const boardElement = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const startButton = document.getElementById('start-button');
        const controls = {
            left: document.getElementById('left'),
            rotate: document.getElementById('rotate'),
            right: document.getElementById('right'),
            down: document.getElementById('down'),
        };

        // --- í…ŒíŠ¸ë¡œë¯¸ë…¸ ëª¨ì–‘ ì •ì˜ --- (ë³€ë™ ì—†ìŒ)
        const TETROMINOS = [
            [[1, COLS + 1, COLS * 2 + 1, 2], [COLS, COLS * 2, COLS * 2 + 1, COLS * 2 + 2], [1, COLS + 1, COLS * 2 + 1, COLS * 2], [COLS, COLS + 1, COLS + 2, COLS * 2 + 2]], // L
            [[1, COLS + 1, COLS * 2 + 1, 0], [COLS, COLS * 2, COLS + 1, COLS + 2], [1, COLS + 1, COLS * 2 + 1, COLS * 2 + 2], [COLS + 2, COLS * 2, COLS * 2 + 1, COLS * 2 + 2]], // J
            [[1, COLS, COLS + 1, COLS + 2], [1, COLS + 1, COLS * 2 + 1, COLS + 2], [COLS, COLS + 1, COLS + 2, COLS * 2 + 1], [1, COLS, COLS + 1, COLS * 2 + 1]], // T
            [[COLS + 1, COLS + 2, COLS * 2, COLS * 2 + 1], [0, COLS, COLS + 1, COLS * 2 + 1]], // S
            [[COLS, COLS + 1, COLS * 2 + 1, COLS * 2 + 2], [1, COLS, COLS + 1, COLS * 2]], // Z
            [[1, COLS + 1, COLS * 2 + 1, COLS * 3 + 1], [COLS, COLS + 1, COLS + 2, COLS + 3], [1, COLS + 1, COLS * 2 + 1, COLS * 3 + 1], [COLS, COLS + 1, COLS + 2, COLS + 3]], // I
            [[0, 1, COLS, COLS + 1]] // O
        ];
        const TETROMINO_NAMES = ['L', 'J', 'T', 'S', 'Z', 'I', 'O'];

        // --- ë³´ë“œ ì´ˆê¸°í™” ---
        function createBoard() {
            boardElement.innerHTML = '';
            gameBoard = [];
            gridState = Array(COLS * ROWS).fill(null);
            for (let i = 0; i < COLS * ROWS; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                boardElement.appendChild(cell);
                gameBoard.push(cell); 
            }
        }

        // --- ë¸”ë¡ ìƒì„± ---
        function generateTetromino() {
            const randomIndex = Math.floor(Math.random() * TETROMINOS.length);
            currentTetromino = TETROMINOS[randomIndex];
            currentTetrominoName = TETROMINO_NAMES[randomIndex];
            currentRotation = 0;
            currentPosition = 4;

            if (checkCollision(currentPosition, currentRotation, 0)) {
                gameOver();
                return false;
            }
            draw();
            return true;
        }

        // --- ë¸”ë¡ ê·¸ë¦¬ê¸°/ì§€ìš°ê¸° ---
        function draw() {
            currentTetromino[currentRotation].forEach(index => {
                const targetIndex = currentPosition + index;
                if (gameBoard[targetIndex]) {
                    gameBoard[targetIndex].classList.add(currentTetrominoName);
                }
            });
        }

        function undraw() {
            currentTetromino[currentRotation].forEach(index => {
                const targetIndex = currentPosition + index;
                if (gameBoard[targetIndex]) {
                    gameBoard[targetIndex].classList.remove(currentTetrominoName);
                }
            });
        }

        // --- ì¶©ëŒ ê°ì§€ --- (ë³€ë™ ì—†ìŒ)
        function checkCollision(nextPosition, nextRotation, direction) {
            return currentTetromino[nextRotation].some(index => {
                const targetIndex = nextPosition + index;
                const nextCol = targetIndex % COLS;
                
                if (targetIndex >= COLS * ROWS) return true;
                if (targetIndex >= 0 && gridState[targetIndex] !== null) return true;

                const currentCol = (currentPosition + index) % COLS;

                if (direction === -1) { 
                    if (nextCol > currentCol) return true; 
                    if (nextCol === COLS - 1) return true; 
                } else if (direction === 1) { 
                    if (nextCol < currentCol) return true; 
                    if (nextCol === 0) return true; 
                }
                
                return false;
            });
        }
        
        // --- ë¸”ë¡ ì´ë™ ë¡œì§ ---
        function move(direction) {
            if (!timerId) return;
            undraw();
            let newPosition = currentPosition + direction;

            if (!checkCollision(newPosition, currentRotation, direction)) {
                currentPosition = newPosition;
            }
            draw();
        }

        // --- ë¸”ë¡ íšŒì „ ë¡œì§ ---
        function rotate() {
            if (!timerId) return;
            undraw();
            const nextRotation = (currentRotation + 1) % currentTetromino.length;

            if (!checkCollision(currentPosition, nextRotation, 0)) {
                currentRotation = nextRotation;
            }
            draw();
        }

        // --- ë¸”ë¡ í•˜ê°• ë¡œì§ ---
        function fall() {
            undraw(); 
            let newPosition = currentPosition + COLS;

            if (checkCollision(newPosition, currentRotation, COLS)) {
                // ì¶©ëŒí–ˆìœ¼ë¯€ë¡œ ë¸”ë¡ì„ ê³ ì •í•˜ê³ , draw()ë¥¼ í˜¸ì¶œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
                freeze();
                checkLines();
                
                // ë¸”ë¡ì„ ê³ ì •í–ˆìœ¼ë‹ˆ DOMì„ ì—…ë°ì´íŠ¸í•˜ì—¬ ì‚¬ë¼ì§€ëŠ” í˜„ìƒì„ í™•ì‹¤íˆ ë§‰ìŠµë‹ˆë‹¤.
                updateDOM(); 
                
                generateTetromino(); // ìƒˆ ë¸”ë¡ ìƒì„±
                
            } else {
                // ì¶©ëŒí•˜ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ ìœ„ì¹˜ë¥¼ ì—…ë°ì´íŠ¸í•˜ê³  ë‹¤ì‹œ ê·¸ë¦½ë‹ˆë‹¤.
                currentPosition = newPosition;
                draw();
            }
        }

        // --- ë¸”ë¡ ê³ ì • (ì‚¬ë¼ì§ ë¬¸ì œ í•´ê²° í•µì‹¬) ---
        function freeze() {
            currentTetromino[currentRotation].forEach(index => {
                const targetIndex = currentPosition + index;
                if (targetIndex >= 0 && targetIndex < COLS * ROWS) {
                    // gridStateì— ì˜êµ¬ì ìœ¼ë¡œ ë¸”ë¡ ì´ë¦„ì„ ì €ì¥í•©ë‹ˆë‹¤.
                    gridState[targetIndex] = currentTetrominoName;
                }
            });
        }

        // --- ì¤„ ì œê±° ë° ì ìˆ˜ ê³„ì‚° ---
        function checkLines() {
            let linesCleared = 0;
            
            for (let i = ROWS - 1; i >= 0; i--) {
                const rowStart = i * COLS;
                const rowState = gridState.slice(rowStart, rowStart + COLS);
                
                const isFull = rowState.every(cellState => cellState !== null);
                
                if (isFull) {
                    linesCleared++;
                    
                    // í•´ë‹¹ ì¤„ì„ gridStateì—ì„œ ì œê±°í•˜ê³  ë§¨ ìœ„ì— ìƒˆ ë¹ˆ ì¤„ì„ ì‚½ì…
                    gridState.splice(rowStart, COLS);
                    const emptyRow = Array(COLS).fill(null);
                    gridState.unshift(...emptyRow);
                }
            }
            
            if (linesCleared > 0) {
                score += linesCleared * 100;
                scoreElement.textContent = score;

                // gridStateì˜ ë³€ê²½ ì‚¬í•­ì„ DOMì— ë°˜ì˜ (ì¤„ì´ ì‚¬ë¼ì§€ê³  ë¸”ë¡ì´ ë‚´ë ¤ì˜´)
                updateDOM();
            }
        }

        // --- DOM ì—…ë°ì´íŠ¸ í•¨ìˆ˜ (ë¸”ë¡ ì‚¬ë¼ì§ ë¬¸ì œ í•´ê²° í•µì‹¬) ---
        function updateDOM() {
            for (let i = 0; i < COLS * ROWS; i++) {
                // 1. ëª¨ë“  ì…€ì˜ í´ë˜ìŠ¤ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤.
                gameBoard[i].className = 'cell'; 
                // 2. gridStateì— ì €ì¥ëœ ê³ ì • ë¸”ë¡ë§Œ ë‹¤ì‹œ ê·¸ë¦½ë‹ˆë‹¤.
                if (gridState[i] !== null) {
                    gameBoard[i].classList.add(gridState[i]);
                }
            }
        }

        // --- ê²Œì„ ì˜¤ë²„ ---
        function gameOver() {
            clearInterval(timerId);
            timerId = null;
            startButton.textContent = 'RESTART';
            alert(`Game Over! Score: ${score}`);
        }

        // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---

        // PC í‚¤ë³´ë“œ ì´ë²¤íŠ¸
        document.addEventListener('keydown', (e) => {
            if (!timerId) return; 

            if (e.key === 'ArrowLeft') move(-1);
            else if (e.key === 'ArrowRight') move(1);
            else if (e.key === 'ArrowDown') fall();
            else if (e.key === 'ArrowUp') rotate();
        });

        // **ë²„íŠ¼ ì‘ë™ ì˜¤ë¥˜ ìˆ˜ì •: touchstartì™€ click ì´ë²¤íŠ¸ë¥¼ ëª¨ë‘ ì‚¬ìš©í•˜ì—¬ PC/ëª¨ë°”ì¼ì„ í¬ê´„**

        function handleControlAction(action) {
            if (!timerId) return;
            // ì•¡ì…˜ ì‹¤í–‰
            if (action === 'left') move(-1);
            else if (action === 'right') move(1);
            else if (action === 'down') fall();
            else if (action === 'rotate') rotate();
        }

        // ëª¨ë°”ì¼ í„°ì¹˜ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (í„°ì¹˜ ì˜¤ë¥˜ ë°©ì§€)
        controls.left.addEventListener('touchstart', (e) => { e.preventDefault(); handleControlAction('left'); });
        controls.right.addEventListener('touchstart', (e) => { e.preventDefault(); handleControlAction('right'); });
        controls.down.addEventListener('touchstart', (e) => { e.preventDefault(); handleControlAction('down'); });
        controls.rotate.addEventListener('touchstart', (e) => { e.preventDefault(); handleControlAction('rotate'); });

        // PC ë§ˆìš°ìŠ¤ í´ë¦­ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ (ë§ˆìš°ìŠ¤ í´ë¦­ ì‘ë™ ë³´ì¥)
        controls.left.addEventListener('click', () => { handleControlAction('left'); });
        controls.right.addEventListener('click', () => { handleControlAction('right'); });
        controls.down.addEventListener('click', () => { handleControlAction('down'); });
        controls.rotate.addEventListener('click', () => { handleControlAction('rotate'); });


        // ê²Œì„ ì‹œì‘/ì¼ì‹œì •ì§€ ë²„íŠ¼
        startButton.addEventListener('click', () => {
            if (timerId) {
                // ì¼ì‹œ ì •ì§€
                clearInterval(timerId);
                timerId = null;
                startButton.textContent = 'RESUME';
            } else {
                if (startButton.textContent === 'START' || startButton.textContent === 'RESTART') {
                    // ìƒˆ ê²Œì„ ì‹œì‘
                    createBoard(); 
                    score = 0;
                    scoreElement.textContent = score;
                    generateTetromino();
                }
                
                // ê²Œì„ ì¬ê°œ ë˜ëŠ” ì‹œì‘
                timerId = setInterval(fall, 800); 
                startButton.textContent = 'PAUSE';
            }
        });

        // --- ì´ˆê¸° ì‹¤í–‰ ---
        createBoard();
    </script>
</body>
</html>
