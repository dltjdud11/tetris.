<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ëª¨ë°”ì¼ í…ŒíŠ¸ë¦¬ìŠ¤ ê²Œì„ (ìµœì¢… ì•ˆì •í™”)</title>
    
    <style>
        /* CSS ìŠ¤íƒ€ì¼: ì´ì „ ë²„ì „ê³¼ ë™ì¼ */
        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding-top: 20px;
            background-color: #333;
            font-family: Arial, sans-serif;
            color: white;
            overflow: hidden; 
            user-select: none;
            box-sizing: border-box;
        }

        .game-wrapper {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            background-color: #222;
            border-radius: 8px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
        }

        #game-board {
            display: grid;
            grid-template-rows: repeat(20, 1fr); 
            grid-template-columns: repeat(10, 1fr);
            width: 300px; 
            height: 600px;
            border: 3px solid #ccc;
            background-color: #111;
        }

        .cell {
            width: 100%;
            height: 100%;
            box-sizing: border-box;
            border: 1px solid #000;
        }

        /* í…ŒíŠ¸ë¡œë¯¸ë…¸ ë¸”ë¡ ìƒ‰ìƒ */
        .T { background-color: purple; border-color: #6a0080; }
        .L { background-color: orange; border-color: #cc6600; }
        .J { background-color: blue; border-color: #000080; }
        .S { background-color: green; border-color: #004d00; }
        .Z { background-color: red; border-color: #800000; }
        .I { background-color: cyan; border-color: #008080; }
        .O { background-color: yellow; border-color: #808000; }

        .info-panel {
            width: 300px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            font-size: 1.2em;
        }
        
        #start-button {
            padding: 10px 15px;
            font-size: 16px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        
        /* ëª¨ë°”ì¼ ì»¨íŠ¸ë¡¤ ìŠ¤íƒ€ì¼ë§ */
        .controls {
            display: flex;
            justify-content: space-around;
            width: 100%;
            padding: 15px 0;
        }

        .controls button {
            padding: 15px 25px;
            font-size: 24px;
            background-color: #444;
            color: white;
            border: 2px solid #666;
            border-radius: 10px;
            cursor: pointer;
            touch-action: manipulation; 
            flex-grow: 1; 
            margin: 0 5px;
            min-width: 60px;
            height: 60px;
        }

        @media (max-width: 600px) {
            #game-board, .info-panel {
                width: 90vw; 
                max-width: 300px;
            }
            #game-board {
                height: calc(90vw * 2); 
                max-height: 600px;
            }
            .controls {
                width: 90vw;
                max-width: 320px;
            }
        }
    </style>
</head>
<body>
    <div class="game-wrapper">
        <div class="info-panel">
            <p>SCORE: <span id="score">0</span></p>
            <button id="start-button">START</button>
        </div>
        
        <div id="game-board">
            </div>
        
        <div class="controls">
            <button id="left">â¬…ï¸</button>
            <button id="rotate">ğŸ”„</button>
            <button id="right">â¡ï¸</button>
            <button id="down">â¬‡ï¸</button>
        </div>
    </div>
    
    <script>
        // --- ê²Œì„ ì„¤ì • ---
        const COLS = 10;
        const ROWS = 20;
        let score = 0;
        let gameBoard = []; 
        let gridState = Array(COLS * ROWS).fill(null); 
        
        let currentTetromino;
        let currentTetrominoName;
        let currentRotation = 0;
        let currentPosition = 4;
        let timerId = null;

        const boardElement = document.getElementById('game-board');
        const scoreElement = document.getElementById('score');
        const startButton = document.getElementById('start-button');
        const controls = {
            left: document.getElementById('left'),
            rotate: document.getElementById('rotate'),
            right: document.getElementById('right'),
            down: document.getElementById('down'),
        };

        // --- í…ŒíŠ¸ë¡œë¯¸ë…¸ ëª¨ì–‘ ì •ì˜ ---
        const TETROMINOS = [
            [[1, COLS + 1, COLS * 2 + 1, 2], [COLS, COLS * 2, COLS * 2 + 1, COLS * 2 + 2], [1, COLS + 1, COLS * 2 + 1, COLS * 2], [COLS, COLS + 1, COLS + 2, COLS * 2 + 2]], // L
            [[1, COLS + 1, COLS * 2 + 1, 0], [COLS, COLS * 2, COLS + 1, COLS + 2], [1, COLS + 1, COLS * 2 + 1, COLS * 2 + 2], [COLS + 2, COLS * 2, COLS * 2 + 1, COLS * 2 + 2]], // J
            [[1, COLS, COLS + 1, COLS + 2], [1, COLS + 1, COLS * 2 + 1, COLS + 2], [COLS, COLS + 1, COLS + 2, COLS * 2 + 1], [1, COLS, COLS + 1, COLS * 2 + 1]], // T
            [[COLS + 1, COLS + 2, COLS * 2, COLS * 2 + 1], [0, COLS, COLS + 1, COLS * 2 + 1]], // S
            [[COLS, COLS + 1, COLS * 2 + 1, COLS * 2 + 2], [1, COLS, COLS + 1, COLS * 2]], // Z
            [[1, COLS + 1, COLS * 2 + 1, COLS * 3 + 1], [COLS, COLS + 1, COLS + 2, COLS + 3], [1, COLS + 1, COLS * 2 + 1, COLS * 3 + 1], [COLS, COLS + 1, COLS + 2, COLS + 3]], // I
            [[0, 1, COLS, COLS + 1]] // O
        ];
        const TETROMINO_NAMES = ['L', 'J', 'T', 'S', 'Z', 'I', 'O'];

        // --- ë³´ë“œ ì´ˆê¸°í™” ---
        function createBoard() {
            boardElement.innerHTML = '';
            gameBoard = [];
            gridState = Array(COLS * ROWS).fill(null);
            for (let i = 0; i < COLS * ROWS; i++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                boardElement.appendChild(cell);
                gameBoard.push(cell); 
            }
        }

        // --- ë¸”ë¡ ìƒì„± ---
        function generateTetromino() {
            const randomIndex = Math.floor(Math.random() * TETROMINOS.length);
            currentTetromino = TETROMINOS[randomIndex];
            currentTetrominoName = TETROMINO_NAMES[randomIndex];
            currentRotation = 0;
            currentPosition = 4;

            if (checkCollision(currentPosition, currentRotation, 0)) {
                gameOver();
                return false;
            }
            draw();
            return true;
        }

        // --- ë¸”ë¡ ê·¸ë¦¬ê¸°/ì§€ìš°ê¸° ---
        // ê·¸ë¦¬ê¸°: DOMì— ë¸”ë¡ í´ë˜ìŠ¤ ì¶”ê°€
        function draw() {
            currentTetromino[currentRotation].forEach(index => {
                const targetIndex = currentPosition + index;
                if (gameBoard[targetIndex]) {
                    gameBoard[targetIndex].classList.add(currentTetrominoName);
                }
            });
        }

        // ì§€ìš°ê¸°: DOMì—ì„œ ë¸”ë¡ í´ë˜ìŠ¤ ì œê±°
        function undraw() {
            currentTetromino[currentRotation].forEach(index => {
                const targetIndex = currentPosition + index;
                if (gameBoard[targetIndex]) {
                    gameBoard[targetIndex].classList.remove(currentTetrominoName);
                }
            });
        }

        // --- ì¶©ëŒ ê°ì§€ ---
        // direction: -1(ì¢Œ), 1(ìš°), COLS(í•˜), 0(íšŒì „)
        function checkCollision(nextPosition, nextRotation, direction) {
            return currentTetromino[nextRotation].some(index => {
                const targetIndex = nextPosition + index;
                const nextCol = targetIndex % COLS;
                
                // 1. ë³´ë“œ ë°”ë‹¥ì„ ë„˜ì—ˆëŠ”ì§€
                if (targetIndex >= COLS * ROWS) return true;
                
                // 2. ì´ë¯¸ ê³ ì •ëœ ë¸”ë¡ì— ì¶©ëŒí•˜ëŠ”ì§€
                // targetIndexê°€ ìŒìˆ˜ê°€ ì•„ë‹Œì§€ (ê°€ë” -COLSê°€ ë  ìˆ˜ ìˆìŒ) && gridStateì— ì´ë¯¸ ë¸”ë¡ì´ ìˆëŠ”ì§€ í™•ì¸
                if (targetIndex >= 0 && gridState[targetIndex] !== null) return true;

                // 3. ë²½ ì¶©ëŒ (ì¢Œ/ìš° ì´ë™ ì‹œ)
                const currentCol = (currentPosition + index) % COLS;

                if (direction === -1) { // ì™¼ìª½ ì´ë™ ì‹œ
                    // ë‹¤ìŒ ì—´ ìœ„ì¹˜ê°€ í˜„ì¬ ì—´ ìœ„ì¹˜ë³´ë‹¤ í¬ê±°ë‚˜ ê°™ìœ¼ë©´ (ë²½ì„ ë„˜ì–´ ë°˜ëŒ€í¸ìœ¼ë¡œ ê°€ë ¤ê³  í•  ë•Œ) ì¶©ëŒ
                    if (nextCol > currentCol) return true; 
                    if (nextCol === COLS - 1) return true; // ì´ ê²½ìš°ëŠ” ì¶©ëŒì´ ì•„ë‹ˆë¼ ë„˜ì–´ê°€ëŠ” ê²ƒì„ ë°©ì§€
                } else if (direction === 1) { // ì˜¤ë¥¸ìª½ ì´ë™ ì‹œ
                    if (nextCol < currentCol) return true; // ë‹¤ìŒ ì—´ ìœ„ì¹˜ê°€ í˜„ì¬ ì—´ ìœ„ì¹˜ë³´ë‹¤ ì‘ìœ¼ë©´ (ë²½ì„ ë„˜ì–´ ë°˜ëŒ€í¸ìœ¼ë¡œ ê°€ë ¤ê³  í•  ë•Œ) ì¶©ëŒ
                    if (nextCol === 0) return true; // ì´ ê²½ìš°ë„ ì¶©ëŒì´ ì•„ë‹ˆë¼ ë„˜ì–´ê°€ëŠ” ê²ƒì„ ë°©ì§€
                }
                
                return false;
            });
        }
        
        // --- ë¸”ë¡ ì´ë™ ë¡œì§ ---
        function move(direction) {
            if (!timerId) return;
            undraw();
            let newPosition = currentPosition + direction;

            if (!checkCollision(newPosition, currentRotation, direction)) {
                currentPosition = newPosition;
            }
            draw();
        }

        // --- ë¸”ë¡ íšŒì „ ë¡œì§ ---
        function rotate() {
            if (!timerId) return;
            undraw();
            const nextRotation = (currentRotation + 1) % currentTetromino.length;

            if (!checkCollision(currentPosition, nextRotation, 0)) {
                currentRotation = nextRotation;
            }
            draw();
        }

        // --- ë¸”ë¡ í•˜ê°• ë¡œì§ ---
        function fall() {
            // í•˜ê°•í•˜ê¸° ì „ í˜„ì¬ ìœ„ì¹˜ì˜ ë¸”ë¡ì„ ì§€ì›ë‹ˆë‹¤.
            undraw(); 
            let newPosition = currentPosition + COLS;

            if (checkCollision(newPosition, currentRotation, COLS)) {
                // ì¶©ëŒí–ˆìœ¼ë¯€ë¡œ (ë°”ë‹¥ ë˜ëŠ” ë‹¤ë¥¸ ë¸”ë¡ì— ë‹¿ìŒ) ë¸”ë¡ì„ ê³ ì •í•©ë‹ˆë‹¤.
                
                // *ì¤‘ìš”*: ê³ ì •í•˜ê¸° ì „ì— draw()ë¥¼ í˜¸ì¶œí•˜ì§€ ì•ŠìŠµë‹ˆë‹¤. 
                // freeze()ê°€ gridStateì™€ DOMì— ìµœì¢… ìœ„ì¹˜ë¥¼ ë°˜ì˜í•©ë‹ˆë‹¤.
                
                freeze();
                checkLines();
                generateTetromino(); // ìƒˆ ë¸”ë¡ ìƒì„±
                
            } else {
                // ì¶©ëŒí•˜ì§€ ì•Šì•˜ìœ¼ë¯€ë¡œ ìœ„ì¹˜ë¥¼ ì—…ë°ì´íŠ¸í•˜ê³  ë‹¤ì‹œ ê·¸ë¦½ë‹ˆë‹¤.
                currentPosition = newPosition;
                draw();
            }
        }

        // --- ë¸”ë¡ ê³ ì • (ì‚¬ë¼ì§ ë¬¸ì œì˜ í•µì‹¬ ìˆ˜ì •) ---
        function freeze() {
            currentTetromino[currentRotation].forEach(index => {
                const targetIndex = currentPosition + index;
                if (targetIndex >= 0 && targetIndex < COLS * ROWS) {
                    // 1. gridStateì— ì˜êµ¬ì ìœ¼ë¡œ ë¸”ë¡ ì´ë¦„ì„ ì €ì¥í•©ë‹ˆë‹¤.
                    gridState[targetIndex] = currentTetrominoName;
                    
                    // 2. DOMì—ë„ ìµœì¢… í´ë˜ìŠ¤ë¥¼ ì¶”ê°€í•˜ì—¬ ì‚¬ë¼ì§€ì§€ ì•Šë„ë¡ í•©ë‹ˆë‹¤.
                    // (ì´ í´ë˜ìŠ¤ëŠ” updateDOM()ì—ì„œ ë‹¤ì‹œ ì„¤ì •ë˜ì§€ë§Œ, ì¦‰ì‹œ ì‹œê°ì  ê³ ì • íš¨ê³¼ë¥¼ ì¤ë‹ˆë‹¤.)
                    gameBoard[targetIndex].classList.add(currentTetrominoName);
                }
            });
        }

        // --- ì¤„ ì œê±° ë° ì ìˆ˜ ê³„ì‚° ---
        function checkLines() {
            let linesCleared = 0;
            
            for (let i = ROWS - 1; i >= 0; i--) {
                const rowStart = i * COLS;
                const rowState = gridState.slice(rowStart, rowStart + COLS);
                
                const isFull = rowState.every(cellState => cellState !== null);
                
                if (isFull) {
                    linesCleared++;
                    
                    // í•´ë‹¹ ì¤„ì„ gridStateì—ì„œ ì œê±°í•˜ê³  ë§¨ ìœ„ì— ìƒˆ ë¹ˆ ì¤„ì„ ì‚½ì…
                    gridState.splice(rowStart, COLS);
                    const emptyRow = Array(COLS).fill(null);
                    gridState.unshift(...emptyRow);
                }
            }
            
            if (linesCleared > 0) {
                score += linesCleared * 100;
                scoreElement.textContent = score;

                // gridStateì˜ ë³€ê²½ ì‚¬í•­ì„ DOMì— ë°˜ì˜ (ì¤„ì´ ì‚¬ë¼ì§€ê³  ë¸”ë¡ì´ ë‚´ë ¤ì˜´)
                updateDOM();
            }
        }

        // --- DOM ì—…ë°ì´íŠ¸ í•¨ìˆ˜ ---
        function updateDOM() {
            for (let i = 0; i < COLS * ROWS; i++) {
                gameBoard[i].className = 'cell'; // ëª¨ë“  ì…€ ì´ˆê¸°í™” (ì‚¬ë¼ì§€ëŠ” í˜„ìƒ ë°©ì§€)
                if (gridState[i] !== null) {
                    gameBoard[i].classList.add(gridState[i]);
                }
            }
        }

        // --- ê²Œì„ ì˜¤ë²„ ---
        function gameOver() {
            clearInterval(timerId);
            timerId = null;
            startButton.textContent = 'RESTART';
            alert(`Game Over! Score: ${score}`);
        }

        // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---

        // PC í‚¤ë³´ë“œ ì´ë²¤íŠ¸
        document.addEventListener('keydown', (e) => {
            if (!timerId) return; 

            if (e.key === 'ArrowLeft') move(-1);
            else if (e.key === 'ArrowRight') move(1);
            else if (e.key === 'ArrowDown') fall();
            else if (e.key === 'ArrowUp') rotate();
        });

        // ëª¨ë°”ì¼/í„°ì¹˜ ë²„íŠ¼ ì´ë²¤íŠ¸ (touchstart ì‚¬ìš© ë° preventDefaultë¡œ í„°ì¹˜ ì˜¤ë¥˜ ë°©ì§€)
        // **touch-action: manipulation;** CSSì™€ **e.preventDefault()** ì¡°í•©ìœ¼ë¡œ í„°ì¹˜ ì˜¤ë¥˜ë¥¼ í•´ê²°í•©ë‹ˆë‹¤.
        controls.left.addEventListener('touchstart', (e) => { e.preventDefault(); move(-1); });
        controls.right.addEventListener('touchstart', (e) => { e.preventDefault(); move(1); });
        controls.down.addEventListener('touchstart', (e) => { e.preventDefault(); fall(); });
        controls.rotate.addEventListener('touchstart', (e) => { e.preventDefault(); rotate(); });


        // ê²Œì„ ì‹œì‘/ì¼ì‹œì •ì§€ ë²„íŠ¼
        startButton.addEventListener('click', () => {
            if (timerId) {
                // ì¼ì‹œ ì •ì§€
                clearInterval(timerId);
                timerId = null;
                startButton.textContent = 'RESUME';
            } else {
                if (startButton.textContent === 'START' || startButton.textContent === 'RESTART') {
                    // ìƒˆ ê²Œì„ ì‹œì‘
                    createBoard(); 
                    score = 0;
                    scoreElement.textContent = score;
                    generateTetromino();
                }
                
                // ê²Œì„ ì¬ê°œ ë˜ëŠ” ì‹œì‘
                timerId = setInterval(fall, 800); // í•˜ê°• ì†ë„: 0.8ì´ˆ
                startButton.textContent = 'PAUSE';
            }
        });

        // --- ì´ˆê¸° ì‹¤í–‰ ---
        createBoard();
    </script>
</body>
</html>
